{
  "version": 3,
  "sources": ["../../three/examples/jsm/objects/Water.js"],
  "sourcesContent": ["import {\r\n\tColor,\r\n\tFrontSide,\r\n\tMatrix4,\r\n\tMesh,\r\n\tPerspectiveCamera,\r\n\tPlane,\r\n\tShaderMaterial,\r\n\tUniformsLib,\r\n\tUniformsUtils,\r\n\tVector3,\r\n\tVector4,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\n\r\n/**\r\n * Work based on :\r\n * https://github.com/Slayvin: Flat mirror for three.js\r\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\r\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\r\n */\r\n\r\nclass Water extends Mesh {\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tsuper( geometry );\r\n\r\n\t\tthis.isWater = true;\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\r\n\t\tconst textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\r\n\r\n\t\tconst clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\r\n\t\tconst alpha = options.alpha !== undefined ? options.alpha : 1.0;\r\n\t\tconst time = options.time !== undefined ? options.time : 0.0;\r\n\t\tconst normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\r\n\t\tconst sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3( 0.70707, 0.70707, 0.0 );\r\n\t\tconst sunColor = new Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );\r\n\t\tconst waterColor = new Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );\r\n\t\tconst eye = options.eye !== undefined ? options.eye : new Vector3( 0, 0, 0 );\r\n\t\tconst distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\r\n\t\tconst side = options.side !== undefined ? options.side : FrontSide;\r\n\t\tconst fog = options.fog !== undefined ? options.fog : false;\r\n\r\n\t\t//\r\n\r\n\t\tconst mirrorPlane = new Plane();\r\n\t\tconst normal = new Vector3();\r\n\t\tconst mirrorWorldPosition = new Vector3();\r\n\t\tconst cameraWorldPosition = new Vector3();\r\n\t\tconst rotationMatrix = new Matrix4();\r\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\r\n\t\tconst clipPlane = new Vector4();\r\n\r\n\t\tconst view = new Vector3();\r\n\t\tconst target = new Vector3();\r\n\t\tconst q = new Vector4();\r\n\r\n\t\tconst textureMatrix = new Matrix4();\r\n\r\n\t\tconst mirrorCamera = new PerspectiveCamera();\r\n\r\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight );\r\n\r\n\t\tconst mirrorShader = {\r\n\r\n\t\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\t\tUniformsLib[ 'fog' ],\r\n\t\t\t\tUniformsLib[ 'lights' ],\r\n\t\t\t\t{\r\n\t\t\t\t\t'normalSampler': { value: null },\r\n\t\t\t\t\t'mirrorSampler': { value: null },\r\n\t\t\t\t\t'alpha': { value: 1.0 },\r\n\t\t\t\t\t'time': { value: 0.0 },\r\n\t\t\t\t\t'size': { value: 1.0 },\r\n\t\t\t\t\t'distortionScale': { value: 20.0 },\r\n\t\t\t\t\t'textureMatrix': { value: new Matrix4() },\r\n\t\t\t\t\t'sunColor': { value: new Color( 0x7F7F7F ) },\r\n\t\t\t\t\t'sunDirection': { value: new Vector3( 0.70707, 0.70707, 0 ) },\r\n\t\t\t\t\t'eye': { value: new Vector3() },\r\n\t\t\t\t\t'waterColor': { value: new Color( 0x555555 ) }\r\n\t\t\t\t}\r\n\t\t\t] ),\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\t\t\t\tuniform mat4 textureMatrix;\r\n\t\t\t\tuniform float time;\r\n\r\n\t\t\t\tvarying vec4 mirrorCoord;\r\n\t\t\t\tvarying vec4 worldPosition;\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <fog_pars_vertex>\r\n\t\t\t\t#include <shadowmap_pars_vertex>\r\n\t\t\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\r\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\r\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t\t#include <beginnormal_vertex>\r\n\t\t\t\t#include <defaultnormal_vertex>\r\n\t\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t\t#include <fog_vertex>\r\n\t\t\t\t#include <shadowmap_vertex>\r\n\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\tuniform sampler2D mirrorSampler;\r\n\t\t\t\tuniform float alpha;\r\n\t\t\t\tuniform float time;\r\n\t\t\t\tuniform float size;\r\n\t\t\t\tuniform float distortionScale;\r\n\t\t\t\tuniform sampler2D normalSampler;\r\n\t\t\t\tuniform vec3 sunColor;\r\n\t\t\t\tuniform vec3 sunDirection;\r\n\t\t\t\tuniform vec3 eye;\r\n\t\t\t\tuniform vec3 waterColor;\r\n\r\n\t\t\t\tvarying vec4 mirrorCoord;\r\n\t\t\t\tvarying vec4 worldPosition;\r\n\r\n\t\t\t\tvec4 getNoise( vec2 uv ) {\r\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\r\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\r\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\r\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\r\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\r\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\r\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\r\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\r\n\t\t\t\t\treturn noise * 0.5 - 1.0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\r\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\r\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\r\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\r\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <packing>\r\n\t\t\t\t#include <bsdfs>\r\n\t\t\t\t#include <fog_pars_fragment>\r\n\t\t\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t\t\t#include <lights_pars_begin>\r\n\t\t\t\t#include <shadowmap_pars_fragment>\r\n\t\t\t\t#include <shadowmask_pars_fragment>\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\r\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\r\n\r\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\r\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\r\n\r\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\r\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\r\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\r\n\r\n\t\t\t\t\tfloat distance = length(worldToEye);\r\n\r\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\r\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\r\n\r\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\r\n\t\t\t\t\tfloat rf0 = 0.3;\r\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\r\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\r\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\r\n\t\t\t\t\tvec3 outgoingLight = albedo;\r\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\r\n\r\n\t\t\t\t\t#include <tonemapping_fragment>\r\n\t\t\t\t\t#include <fog_fragment>\r\n\t\t\t\t}`\r\n\r\n\t\t};\r\n\r\n\t\tconst material = new ShaderMaterial( {\r\n\t\t\tfragmentShader: mirrorShader.fragmentShader,\r\n\t\t\tvertexShader: mirrorShader.vertexShader,\r\n\t\t\tuniforms: UniformsUtils.clone( mirrorShader.uniforms ),\r\n\t\t\tlights: true,\r\n\t\t\tside: side,\r\n\t\t\tfog: fog\r\n\t\t} );\r\n\r\n\t\tmaterial.uniforms[ 'mirrorSampler' ].value = renderTarget.texture;\r\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\r\n\t\tmaterial.uniforms[ 'alpha' ].value = alpha;\r\n\t\tmaterial.uniforms[ 'time' ].value = time;\r\n\t\tmaterial.uniforms[ 'normalSampler' ].value = normalSampler;\r\n\t\tmaterial.uniforms[ 'sunColor' ].value = sunColor;\r\n\t\tmaterial.uniforms[ 'waterColor' ].value = waterColor;\r\n\t\tmaterial.uniforms[ 'sunDirection' ].value = sunDirection;\r\n\t\tmaterial.uniforms[ 'distortionScale' ].value = distortionScale;\r\n\r\n\t\tmaterial.uniforms[ 'eye' ].value = eye;\r\n\r\n\t\tscope.material = material;\r\n\r\n\t\tscope.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t\tmirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\r\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t\tnormal.applyMatrix4( rotationMatrix );\r\n\r\n\t\t\tview.subVectors( mirrorWorldPosition, cameraWorldPosition );\r\n\r\n\t\t\t// Avoid rendering when mirror is facing away\r\n\r\n\t\t\tif ( view.dot( normal ) > 0 ) return;\r\n\r\n\t\t\tview.reflect( normal ).negate();\r\n\t\t\tview.add( mirrorWorldPosition );\r\n\r\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\r\n\r\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\r\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\r\n\t\t\tlookAtPosition.add( cameraWorldPosition );\r\n\r\n\t\t\ttarget.subVectors( mirrorWorldPosition, lookAtPosition );\r\n\t\t\ttarget.reflect( normal ).negate();\r\n\t\t\ttarget.add( mirrorWorldPosition );\r\n\r\n\t\t\tmirrorCamera.position.copy( view );\r\n\t\t\tmirrorCamera.up.set( 0, 1, 0 );\r\n\t\t\tmirrorCamera.up.applyMatrix4( rotationMatrix );\r\n\t\t\tmirrorCamera.up.reflect( normal );\r\n\t\t\tmirrorCamera.lookAt( target );\r\n\r\n\t\t\tmirrorCamera.far = camera.far; // Used in WebGLBackground\r\n\r\n\t\t\tmirrorCamera.updateMatrixWorld();\r\n\t\t\tmirrorCamera.projectionMatrix.copy( camera.projectionMatrix );\r\n\r\n\t\t\t// Update the texture matrix\r\n\t\t\ttextureMatrix.set(\r\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t);\r\n\t\t\ttextureMatrix.multiply( mirrorCamera.projectionMatrix );\r\n\t\t\ttextureMatrix.multiply( mirrorCamera.matrixWorldInverse );\r\n\r\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\r\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\r\n\t\t\tmirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );\r\n\t\t\tmirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );\r\n\r\n\t\t\tclipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );\r\n\r\n\t\t\tconst projectionMatrix = mirrorCamera.projectionMatrix;\r\n\r\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\r\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\r\n\t\t\tq.z = - 1.0;\r\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\r\n\r\n\t\t\t// Calculate the scaled plane vector\r\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\r\n\r\n\t\t\t// Replacing the third row of the projection matrix\r\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\r\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\r\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\r\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\r\n\r\n\t\t\teye.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\t\t// Render\r\n\r\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\r\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification and recursion\r\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\r\n\t\t\trenderer.setRenderTarget( renderTarget );\r\n\r\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\r\n\r\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\r\n\t\t\trenderer.render( scene, mirrorCamera );\r\n\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t\trenderer.xr.enabled = currentXrEnabled;\r\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n\r\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t\t\t// Restore viewport\r\n\r\n\t\t\tconst viewport = camera.viewport;\r\n\r\n\t\t\tif ( viewport !== undefined ) {\r\n\r\n\t\t\t\trenderer.state.viewport( viewport );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Water };\r\n"],
  "mappings": "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",
  "names": []
}
